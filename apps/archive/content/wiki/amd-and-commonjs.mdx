---
title: AMD와 CommonJS
description: AMD와 CommonJS는 JavaScript의 모듈 시스템을 구현하는 두 가지 주요 접근 방식이다. 주로 JavaScript 코드를 모듈화하고 재사용 가능한 코드 단위로 분리하는 데 사용된다.
keywords: AMD, CommonJS
---

## AMD (Asynchronous Module Definition):

- AMD는 비동기적으로 모듈을 로드하고 정의하는 방식을 제공하는 모듈 시스템
- 주로 브라우저 환경에서 사용

### 장점

- **비동기 로딩**: 모듈은 비동기적으로 로드되므로 페이지의 초기 로딩 성능 향상
- **브라우저 환경에 적합**: 브라우저에서 동작하는 웹 애플리케이션에 적합하며, 여러 개의 모듈이 서로 독립적으로 로드되는 상황에서 유용
- **브라우저에 맞는 최적화**: AMD 로더 라이브러리(예: RequireJS)를 사용하여 모듈 로드를 최적화

### 단점

- **복잡성**: 비동기적 모듈 로딩과 관련된 추가 구성과 로직이 필요할 수 있다.
- **브라우저 호환성**: 모든 브라우저에서 AMD를 지원하지 않을 수 있다.

### 예시

```js
// 모듈 정의
define(['dependency1', 'dependency2'], function (dep1, dep2) {
  // 모듈 코드
  return {
    // ...
  }
})

// 모듈 사용
require(['module1', 'module2'], function (mod1, mod2) {
  // 모듈 코드 사용
})
```

## CommonJS:

- 동기적인 모듈 로딩을 기본으로 하는 모듈 시스템
- 주로 서버 사이드 JavaScript 환경(예: Node.js)에서 사용

### 장점

- **동기적 로딩**: 모듈이 동기적으로 로드되기 때문에 코드의 의존성 관리와 로드 순서를 더 쉽게 관리
- **서버 환경에 적합**: 서버 사이드에서 모듈화된 코드를 사용할 때 유용
- **네이티브 지원**: Node.js와 같은 환경에서 CommonJS 모듈 시스템이 네이티브하게 지원되어 추가 라이브러리 없이도 사용 가능

### 단점

- **브라우저 환경**: 브라우저 환경에서는 CommonJS 모듈 시스템이 기본적으로 동작하지 않으며, 번들링 도구(예: Browserify, Webpack)를 사용해야 한다.
- **성능 문제**: 동기적 로딩 방식은 페이지 초기 로딩 성능을 저하시킬 수 있다.

### 예시

```js
// 모듈 정의
const dep1 = require('dependency1')
const dep2 = require('dependency2')

module.exports = {
  // 모듈 코드
}
```

## 차이점

### 로딩 방식

AMD는 비동기적으로, CommonJS는 동기적으로 모듈을 로드한다.

### 환경

AMD는 주로 브라우저 환경에서, CommonJS는 주로 서버 사이드 환경에서 사용된다.

### 사용 사례

AMD는 웹 애플리케이션에서 다양한 모듈을 동적으로 로드해야 할 때 적합하고, CommonJS는 서버 사이드에서 코드 모듈을 다루거나, 브라우저에서 번들링된 코드를 사용할 때 적합하다.
